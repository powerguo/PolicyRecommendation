library(dplyr)
library(ggplot2)
library(tidyr)
library(rstanarm)
library(mlogit)
library(Hmisc)
library(googledrive)
library(googlesheets)
library(survival)
library(DoE.base)
library(DoE.wrapper)
library(mgcv)
library(support.CEs)
library(mlmRev)
library(lme4)
library(rlist)
library(Matrix)
library(matrixStats)
library(pROC)

create.col.nuc <- function(df, n){
  varname <- paste0("nuc.power0", n)
  mutate(df, !!varname := ifelse(nuc.power0 == n, 1,0))
}

create.col.ban <- function(df, n){
  varname <- paste0("ban.fuel.explore0", n)
  mutate(df, !!varname := ifelse(ban.fuel.explore0 == n, 1,0))
}

create.col.RFS <- function(df, n){
  varname <- paste0("RFS0", n)
  mutate(df, !!varname := ifelse(RFS0 == n, 1,0))
}

create.col.nuc1 <- function(df, n){
  varname <- paste0("nuc.power1", n)
  mutate(df, !!varname := ifelse(nuc.power1 == n, 1,0))
}

create.col.ban1 <- function(df, n){
  varname <- paste0("ban.fuel.explore1", n)
  mutate(df, !!varname := ifelse(ban.fuel.explore1 == n, 1,0))
}

create.col.RFS1 <- function(df, n){
  varname <- paste0("RFS1", n)
  mutate(df, !!varname := ifelse(RFS1 == n, 1,0))
}

simulation.parameter <- function(n, b0, b1, b2, b3, b4, b5, b6, b7, pwise){
  
  b0value <- c()
  b1value <- c()
  b2value <- c()
  b3value <- c()
  b4value <- c()
  b5value <- c()
  b6value <- c()
  b7value <- c()
  
  for(i in 1:n){
    
    b0 <- b0
    b1 <- b1
    b2 <- b2
    b3 <- b3/150
    b4 <- b4
    b5 <- b5
    b6 <- b6
    b7 <- b7
    
      alt1.test <- oa.design(factor.names = list(nuc.power =c("Provide financial support to build nuclear power plants that have been planned and proposed while maintaining the existing nuclear power plants. This will add ~13 GW of nuclear power to the existing 92 GW of nuclear capacity", 
                                                              "Provide support and maintain the existing nuclear power capacity of 92 GW (~20%) in the electricity grid. No support for any new or proposed nuclear power plants in the country.", 
                                                              "Phase out unprofitable and scheduled to close nuclear power in the country that will reduce the generation capacity by 13.7-26.8 GW with no planned replacement in the next eight years."),
                                                 CO2Price = c("0", "30", "60", "90", "120", "150"),
                                                 ban.fuel.explore = c("Reinstate 2015 Bureau of Land Management executive order for hydraulic fracturing on public lands that increases storage safety standards and transparency of the chemicals used.", 
                                                                      "Fully ban fossil fuel exploration on public lands", 
                                                                      "No change to status quo"),
                                                 RFS = c("Starting from 2021, reach 100% clean energy by 2035 with a yearly increase of 7.5% of clean energy in the grid", 
                                                         "Starting from 2021, reach 100% clean energy by 2050 with a yearly increase of 3.5% of clean energy in the grid", 
                                                         "Starting from 2021, reach 100% clean energy by 2100 with a yearly increase of 1.3% of clean energy in the grid")))
      
      #pwise denotes the number of doptimal questions you want to ask. 
      
      alt.left.test <- Dopt.augment(alt1.test, m = (pwise-18))
      
      is.duplicate <- anyDuplicated(alt.left.test)
      
      while(is.duplicate > 0){
        
        alt.left.test <- alt.left.test[-c(is.duplicate),]
        
        alt.left.test1 <- Dopt.augment(alt1.test, m =1)
        appended <- alt.left.test1[19,]
        alt.left.test <- rbind(alt.left.test, appended)
        is.duplicate <- (anyDuplicated(alt.left.test))
        }
    
   
    alt.left.num.test <- alt.left.test%>%
      mutate(nuc.power = ifelse(nuc.power == "Provide financial support to build nuclear power plants that have been planned and proposed while maintaining the existing nuclear power plants. This will add ~13 GW of nuclear power to the existing 92 GW of nuclear capacity", 0, ifelse(
        nuc.power == "Provide support and maintain the existing nuclear power capacity of 92 GW (~20%) in the electricity grid. No support for any new or proposed nuclear power plants in the country.", 1, 2)
      ))%>%
      mutate(CO2Price = ifelse(CO2Price == "0", 0, ifelse(
        CO2Price == "30", 1, ifelse(
          CO2Price == "60", 2, ifelse(
            CO2Price =="90", 3, ifelse(
              CO2Price == "120", 4, 5
            )
          )
        ) 
      )))%>%
      mutate(ban.fuel.explore = ifelse(ban.fuel.explore == "Reinstate 2015 Bureau of Land Management executive order for hydraulic fracturing on public lands that increases storage safety standards and transparency of the chemicals used.", 0, ifelse(
        ban.fuel.explore == "Fully ban fossil fuel exploration on public lands", 1, 2
      )))%>%
      mutate(RFS = ifelse(RFS == "Starting from 2021, reach 100% clean energy by 2035 with a yearly increase of 7.5% of clean energy in the grid", 0, ifelse(
        RFS == "Starting from 2021, reach 100% clean energy by 2050 with a yearly increase of 3.5% of clean energy in the grid", 1, 2)))
    
    alt.right.num.test <- alt.left.num.test%>%
      mutate(nuc.power = (nuc.power + 1)%%3)%>%
      mutate(ban.fuel.explore = (ban.fuel.explore + 1)%%3)%>%
      mutate(RFS = (RFS + 1)%%3)%>%
      mutate(CO2Price = (CO2Price + 1)%%6)%>%
      dplyr::select(nuc.power, CO2Price, ban.fuel.explore, RFS)
    
    alt.left.txt <- alt.left.num.test%>%
      mutate(CO2Price = ifelse(CO2Price == "0", 0, ifelse(
        CO2Price == "1", 30, ifelse(
          CO2Price == "2", 60, ifelse(
            CO2Price =="3", 90, ifelse(
              CO2Price =="4", 120, 150
            )
          )
        )
      )))%>%
      mutate(nuc.power0 = nuc.power)%>%
      mutate(CO2Price0 = CO2Price)%>%
      mutate(ban.fuel.explore0 = ban.fuel.explore)%>%
      mutate(RFS0 = RFS)%>%
      dplyr::select(nuc.power0, CO2Price0, ban.fuel.explore0, RFS0)
    
    
    alt.right.txt <- alt.right.num.test%>%
      mutate(CO2Price = ifelse(CO2Price == "0", 0, ifelse(
        CO2Price == "1", 30, ifelse(
          CO2Price == "2", 60, ifelse(
            CO2Price =="3", 90, ifelse(
              CO2Price =="4", 120, 150
            )
          )
        )
      )))%>%
      mutate(nuc.power1 = nuc.power)%>%
      mutate(CO2Price1 = CO2Price)%>%
      mutate(ban.fuel.explore1 = ban.fuel.explore)%>%
      mutate(RFS1 = RFS)%>%
      dplyr::select(nuc.power1, CO2Price1, ban.fuel.explore1, RFS1)
    
    total.design.test <- cbind(alt.left.txt, alt.right.txt)
    
    total.design.test.1 <- total.design.test%>%
      create.col.nuc(1)%>%
      create.col.nuc(2)%>%
      create.col.ban(1)%>%
      create.col.ban(2)%>%
      create.col.RFS(1)%>%
      create.col.RFS(2)%>%
      create.col.nuc1(1)%>%
      create.col.nuc1(2)%>%
      create.col.ban1(1)%>%
      create.col.ban1(2)%>%
      create.col.RFS1(1)%>%
      create.col.RFS1(2)%>%
      dplyr::select(nuc.power01, nuc.power02, CO2Price0, ban.fuel.explore01, ban.fuel.explore02, RFS01, RFS02, nuc.power11, nuc.power12, CO2Price1, ban.fuel.explore11, ban.fuel.explore12, RFS11, RFS12)
    
    
    utility.matrix <- as.matrix(total.design.test.1[,1:7] - total.design.test.1[,8:14])
    
    colnames(utility.matrix) <- c("nuc.power1", "nuc.power2", "CO2Price", "ban.fuel.explore1", "ban.fuel.explore2", "RFS1", "RFS2")
    
    total.design.ut <- as.data.frame(utility.matrix)%>%
      mutate(id = rep(1:pwise))%>%
      mutate(utility = b1*nuc.power1 + b2*nuc.power2 + b3*CO2Price + b4*ban.fuel.explore1 + b5*ban.fuel.explore2 + b6*RFS1 + b7*RFS2)%>%
      mutate(p = (exp(utility)/(1+exp(utility))))

    p.values <- total.design.ut$p
    id.sim <- rep(1, pwise)
    Choice <- rbinom(pwise, 1, total.design.ut$p)
    
    total.design.simulate <- cbind(total.design.test, p.values, Choice, id.sim)%>%
      mutate(Choices = ifelse(Choice == "0", 1, 0))%>%
      mutate(nuc.power_0 = as.factor(nuc.power0))%>%
      mutate(nuc.power_1 = as.factor(nuc.power1))%>%
      mutate(CO2Price_0 = CO2Price0)%>%
      mutate(CO2Price_1 = CO2Price1)%>%
      mutate(ban.fuel.explore_0 = as.factor(ban.fuel.explore0))%>%
      mutate(ban.fuel.explore_1 = as.factor(ban.fuel.explore1))%>%
      mutate(RFS_0 = as.factor(RFS0))%>%
      mutate(RFS_1 = as.factor(RFS1))%>%
      dplyr::select(id.sim, Choices, nuc.power_0, nuc.power_1, CO2Price_0, CO2Price_1, ban.fuel.explore_0, ban.fuel.explore_1, RFS_0, RFS_1)
    
    dataset.sim <- mlogit.data(total.design.simulate, shape = "wide", choice = "Choices", varying = c(3:10), sep = "_")
    
    sim.utility <- glm(Choices ~ nuc.power + CO2Price + ban.fuel.explore + RFS, data = dataset.sim, family = binomial(link = "logit"))
    
    
    b0t <- sim.utility$coefficients[2]-(-sim.utility$coefficients[1]/7)
    b1t <- (sim.utility$coefficients[3])-(-sim.utility$coefficients[1]/7)
    b2t <- (sim.utility$coefficients[4]/150) -(-sim.utility$coefficients[1]/(7*150))
    b3t <- sim.utility$coefficients[5]-(-sim.utility$coefficients[1]/7)
    b4t <- (sim.utility$coefficients[6])-(-sim.utility$coefficients[1]/7)
    b5t <- sim.utility$coefficients[7] -(-sim.utility$coefficients[1]/7)
    b6t <- sim.utility$coefficients[8] -(-sim.utility$coefficients[1]/7)
    b7t <- sim.utility$coefficients[1]
  
  
    
    b0value[i] <- b0t
    b1value[i] <- b1t
    b2value[i] <- b2t
    b3value[i] <- b3t
    b4value[i] <- b4t
    b5value[i] <- b5t
    b6value[i] <- b6t
    b7value[i] <- b7t

  }
  
  mylist <- list(b0value, b1value, b2value, b3value, b4value, b5value, b6value, b7value)
  return(mylist)
  
}

test1 <- simulation.parameter(1000, 0, 0.5, 1, 2, 0.5, 1, 0.7, 1.5, 44)
test2 <- simulation.parameter(100, 0, 0.5, 1, 2, 0.5, 1, 0.7, 1.5, 44)
test3 <- simulation.parameter(500, 0, 0.5, 1, 2, 0.5, 1, 0.7, 1.5, 44)
test4 <- simulation.parameter(500, 0, 0.5, 1, 2, 0.5, 1, 0.7, 1.5, 19)
test5 <- simulation.parameter(500, 0, 0.5, 1, 2, 0.5, 1, 0.7, 1.5, 26)
test6 <- simulation.parameter(500, 0, 0.5, 1, 2, 0.5, 1, 0.7, 1.5, 36)

test1mean <- list(mean(test1[[1]]), mean(test1[[2]]), mean(test1[[3]]), mean(test1[[4]]), mean(test1[[5]]), mean(test1[[6]]), mean(test1[[7]]), mean(test1[[8]]))
test1mean

test1sd <- list(sd(test1[[1]]), sd(test1[[2]]), sd(test1[[3]]), sd(test1[[4]]), sd(test1[[5]]), sd(test1[[6]]), sd(test1[[7]]), sd(test1[[8]]))
test1sd

test2mean <- list(mean(test2[[1]]), mean(test2[[2]]), mean(test2[[3]]), mean(test2[[4]]), mean(test2[[5]]), mean(test2[[6]]), mean(test2[[7]]), mean(test2[[8]]))
test2mean

test2sd <- list(sd(test2[[1]]), sd(test2[[2]]), sd(test2[[3]]), sd(test2[[4]]), sd(test2[[5]]), sd(test2[[6]]), sd(test2[[7]]), sd(test2[[8]]))
test2sd

test3mean <- list(mean(test3[[1]]), mean(test3[[2]]), mean(test3[[3]]), mean(test3[[4]]), mean(test3[[5]]), mean(test3[[6]]), mean(test3[[7]]), mean(test3[[8]]))
test3mean

test3sd <- list(sd(test3[[1]]), sd(test3[[2]]), sd(test3[[3]]), sd(test3[[4]]), sd(test3[[5]]), sd(test3[[6]]), sd(test3[[7]]), sd(test3[[8]]))
test3sd

test4mean <- list(mean(test4[[1]]), mean(test4[[2]]), mean(test4[[3]]), mean(test4[[4]]), mean(test4[[5]]), mean(test4[[6]]), mean(test4[[7]]), mean(test4[[8]]))
test4mean

test4sd <- list(sd(test4[[1]]), sd(test4[[2]]), sd(test4[[3]]), sd(test4[[4]]), sd(test4[[5]]), sd(test4[[6]]), sd(test4[[7]]), sd(test4[[8]]))
test4sd

test5mean <- list(mean(test5[[1]]), mean(test5[[2]]), mean(test5[[3]]), mean(test5[[4]]), mean(test5[[5]]), mean(test5[[6]]), mean(test5[[7]]), mean(test5[[8]]))
test5mean

test5sd <- list(sd(test5[[1]]), sd(test5[[2]]), sd(test5[[3]]), sd(test5[[4]]), sd(test5[[5]]), sd(test5[[6]]), sd(test5[[7]]), sd(test5[[8]]))
test5sd

test6mean <- list(mean(test6[[1]]), mean(test6[[2]]), mean(test6[[3]]), mean(test6[[4]]), mean(test6[[5]]), mean(test6[[6]]), mean(test6[[7]]), mean(test6[[8]]))
test6mean

test6sd <- list(sd(test6[[1]]), sd(test6[[2]]), sd(test6[[3]]), sd(test6[[4]]), sd(test6[[5]]), sd(test6[[6]]), sd(test6[[7]]), sd(test6[[8]]))
test6sd

changeiterations.mean <- rbind(test1mean, test2mean, test3mean)

row.names <- rownames(changeiterations.mean)
changeiterations.sd <- rbind(test1sd, test2sd, test3sd)

changeiteration <- as.data.frame(cbind(row.names, changeiterations.mean))

colnames(changeiteration) <- c( "testiteration", "para1mean", "para2mean", "para3mean", "para4mean", "para5mean", "para6mean", "para7mean", "para8mean")

changeiteration.1 <- changeiteration%>%
  dplyr::select(-para3mean, -para8mean)%>%
  gather(key = "parameter", value = "mean", -"testiteration")%>%
  mutate(mean = as.numeric(mean))%>%
  mutate(mean1 = ifelse(parameter == "para1mean", mean - 0.5, ifelse(parameter == "para2mean", mean - 1, ifelse(parameter == "para4mean", mean - 0.5, ifelse(
    parameter =="para5mean", mean - 1, ifelse(parameter =="para6mean", mean - 0.7, mean -1.5)
  )))))

change.sd <- as.data.frame(changeiterations.sd)
colnames(change.sd) <- c("para1sd", "para2sd", "para3sd", "para4sd", "para5sd", "para6sd", "para7sd", "para8sd")

changeiteration.2 <- change.sd%>%
  dplyr::select(-para3sd, -para8sd)%>%
  gather(key = "parametersd", value = "sd")%>%
  mutate(sd = as.numeric(sd))
  

changeit <- cbind(changeiteration.1, changeiteration.2)%>%
  mutate(cco = ifelse(testiteration == "test1mean", "red", ifelse(testiteration == "test2mean", "blue", "green")))

ggplot(changeit, aes(x = parameter, y = mean, fill = cco)) +
  geom_bar(stat = "identity", position = "dodge")+
  geom_errorbar(aes(ymin = mean - (sd), ymax = mean +(sd)), position = position_dodge(0.9))

alt1.test <- fac.design(factor.names = list(nuc.power =c("Provide financial support to build nuclear power plants that have been planned and proposed while maintaining the existing nuclear power plants. This will add ~13 GW of nuclear power to the existing 92 GW of nuclear capacity", 
                                                        "Provide support and maintain the existing nuclear power capacity of 92 GW (~20%) in the electricity grid. No support for any new or proposed nuclear power plants in the country.", 
                                                        "Phase out unprofitable and scheduled to close nuclear power in the country that will reduce the generation capacity by 13.7-26.8 GW with no planned replacement in the next eight years."),
                                           CO2Price = c("0", "30", "60", "90", "120", "150"),
                                           ban.fuel.explore = c("Reinstate 2015 Bureau of Land Management executive order for hydraulic fracturing on public lands that increases storage safety standards and transparency of the chemicals used.", 
                                                                "Fully ban fossil fuel exploration on public lands", 
                                                                "No change to status quo"),
                                           RFS = c("Starting from 2021, reach 100% clean energy by 2035 with a yearly increase of 7.5% of clean energy in the grid", 
                                                   "Starting from 2021, reach 100% clean energy by 2050 with a yearly increase of 3.5% of clean energy in the grid", 
                                                   "Starting from 2021, reach 100% clean energy by 2100 with a yearly increase of 1.3% of clean energy in the grid")))


alt.left.num.test <- alt1.test%>%
  mutate(nuc.power = ifelse(nuc.power == "Provide financial support to build nuclear power plants that have been planned and proposed while maintaining the existing nuclear power plants. This will add ~13 GW of nuclear power to the existing 92 GW of nuclear capacity", 0, ifelse(
    nuc.power == "Provide support and maintain the existing nuclear power capacity of 92 GW (~20%) in the electricity grid. No support for any new or proposed nuclear power plants in the country.", 1, 2)
  ))%>%
  mutate(CO2Price = ifelse(CO2Price == "0", 0, ifelse(
    CO2Price == "30", 1, ifelse(
      CO2Price == "60", 2, ifelse(
        CO2Price =="90", 3, ifelse(
          CO2Price == "120", 4, 5
        )
      )
    ) 
  )))%>%
  mutate(ban.fuel.explore = ifelse(ban.fuel.explore == "Reinstate 2015 Bureau of Land Management executive order for hydraulic fracturing on public lands that increases storage safety standards and transparency of the chemicals used.", 0, ifelse(
    ban.fuel.explore == "Fully ban fossil fuel exploration on public lands", 1, 2
  )))%>%
  mutate(RFS = ifelse(RFS == "Starting from 2021, reach 100% clean energy by 2035 with a yearly increase of 7.5% of clean energy in the grid", 0, ifelse(
    RFS == "Starting from 2021, reach 100% clean energy by 2050 with a yearly increase of 3.5% of clean energy in the grid", 1, 2)))

alt.right.num.test <- alt.left.num.test%>%
  mutate(nuc.power = (nuc.power + 1)%%3)%>%
  mutate(ban.fuel.explore = (ban.fuel.explore + 1)%%3)%>%
  mutate(RFS = (RFS + 1)%%3)%>%
  mutate(CO2Price = (CO2Price + 1)%%6)%>%
  dplyr::select(nuc.power, CO2Price, ban.fuel.explore, RFS)

alt.left.txt <- alt.left.num.test%>%
  mutate(CO2Price = ifelse(CO2Price == "0", 0, ifelse(
    CO2Price == "1", 30, ifelse(
      CO2Price == "2", 60, ifelse(
        CO2Price =="3", 90, ifelse(
          CO2Price =="4", 120, 150
        )
      )
    )
  )))%>%
  mutate(nuc.power0 = nuc.power)%>%
  mutate(CO2Price0 = CO2Price)%>%
  mutate(ban.fuel.explore0 = ban.fuel.explore)%>%
  mutate(RFS0 = RFS)%>%
  dplyr::select(nuc.power0, CO2Price0, ban.fuel.explore0, RFS0)


alt.right.txt <- alt.right.num.test%>%
  mutate(CO2Price = ifelse(CO2Price == "0", 0, ifelse(
    CO2Price == "1", 30, ifelse(
      CO2Price == "2", 60, ifelse(
        CO2Price =="3", 90, ifelse(
          CO2Price =="4", 120, 150
        )
      )
    )
  )))%>%
  mutate(nuc.power1 = nuc.power)%>%
  mutate(CO2Price1 = CO2Price)%>%
  mutate(ban.fuel.explore1 = ban.fuel.explore)%>%
  mutate(RFS1 = RFS)%>%
  dplyr::select(nuc.power1, CO2Price1, ban.fuel.explore1, RFS1)

total.design.test <- cbind(alt.left.txt, alt.right.txt)

total.design.test.1 <- total.design.test%>%
  create.col.nuc(1)%>%
  create.col.nuc(2)%>%
  create.col.ban(1)%>%
  create.col.ban(2)%>%
  create.col.RFS(1)%>%
  create.col.RFS(2)%>%
  create.col.nuc1(1)%>%
  create.col.nuc1(2)%>%
  create.col.ban1(1)%>%
  create.col.ban1(2)%>%
  create.col.RFS1(1)%>%
  create.col.RFS1(2)%>%
  dplyr::select(nuc.power01, nuc.power02, CO2Price0, ban.fuel.explore01, ban.fuel.explore02, RFS01, RFS02, nuc.power11, nuc.power12, CO2Price1, ban.fuel.explore11, ban.fuel.explore12, RFS11, RFS12)

ut.matrix <- total.design.test.1%>%
  dplyr::select(nuc.power01, nuc.power02, CO2Price0, ban.fuel.explore01, ban.fuel.explore02, RFS01, RFS02)%>%
  mutate(id = rep(1:nrow(total.design.test.1)))



colnames(ut.matrix) <- c("nuc.power1", "nuc.power2", "CO2Price", "ban.fuel.explore1", "ban.fuel.explore2", "RFS1", "RFS2", "id")

utility.matrix <- as.matrix(total.design.test.1[,1:7] - total.design.test.1[,8:14])

colnames(utility.matrix) <- c("nuc.power1", "nuc.power2", "CO2Price", "ban.fuel.explore1", "ban.fuel.explore2", "RFS1", "RFS2")

utility.generation <- function(utility.matrix, b1, b2, b3, b4, b5, b6, b7){
  
  b0value <- c()
  b1value <- c()
  b2value <- c()
  b3value <- c()
  b4value <- c()
  b5value <- c()
  b6value <- c()
  b7value <- c()
  
  b1 <- b1
  b2 <- b2
  b3 <- b3/150
  b4 <- b4
  b5 <- b5
  b6 <- b6
  b7 <- b7
  
  total.design.ut <- as.data.frame(utility.matrix)%>%
    mutate(id = rep(1:nrow(utility.matrix)))%>%
    mutate(utility = b1*nuc.power1 + b2*nuc.power2 + b3*CO2Price + b4*ban.fuel.explore1 + b5*ban.fuel.explore2 + b6*RFS1 + b7*RFS2)%>%
    mutate(p = (exp(utility)/(1+exp(utility))))
  
  p.values <- total.design.ut$p
  id.sim <- rep(1, nrow(utility.matrix))
  Choice <- rbinom(nrow(utility.matrix), 1, total.design.ut$p)
  
  total.design.simulate <- cbind(total.design.test, p.values, Choice, id.sim)%>%
    mutate(Choices = ifelse(Choice == "0", 1, 0))%>%
    mutate(nuc.power_0 = as.factor(nuc.power0))%>%
    mutate(nuc.power_1 = as.factor(nuc.power1))%>%
    mutate(CO2Price_0 = CO2Price0)%>%
    mutate(CO2Price_1 = CO2Price1)%>%
    mutate(ban.fuel.explore_0 = as.factor(ban.fuel.explore0))%>%
    mutate(ban.fuel.explore_1 = as.factor(ban.fuel.explore1))%>%
    mutate(RFS_0 = as.factor(RFS0))%>%
    mutate(RFS_1 = as.factor(RFS1))%>%
    dplyr::select(id.sim, Choices, nuc.power_0, nuc.power_1, CO2Price_0, CO2Price_1, ban.fuel.explore_0, ban.fuel.explore_1, RFS_0, RFS_1)
  
  dataset.sim <- mlogit.data(total.design.simulate, shape = "wide", choice = "Choices", varying = c(3:10), sep = "_")
  
  sim.utility <- glm(Choices ~ nuc.power + CO2Price + ban.fuel.explore + RFS, data = dataset.sim, family = binomial(link = "logit"))
  
  
  b0t <- sim.utility$coefficients[2]
  b1t <- (sim.utility$coefficients[3])
  b2t <- (sim.utility$coefficients[4]/150)
  b3t <- sim.utility$coefficients[5]
  b4t <- (sim.utility$coefficients[6])
  b5t <- sim.utility$coefficients[7] 
  b6t <- sim.utility$coefficients[8] 
  b7t <- sim.utility$coefficients[1]
  
  
  mylist <- list(b0t, b1t, b2t, b3t, b4t, b5t, b6t, b7t)
  return(mylist)
  
}

utility.calculation <- function(utility.matrix, b1, b2, b3, b4, b5, b6, b7, b8){
  
  total.design.ut <- as.data.frame(utility.matrix)%>%
    mutate(id = rep(1:nrow(utility.matrix)))%>%
    mutate(utility = b1*nuc.power1 + b2*nuc.power2 + b3*CO2Price + b4*ban.fuel.explore1 + b5*ban.fuel.explore2 + b6*RFS1 + b7*RFS2 + b8)
  
  return(total.design.ut)
  
}

p1 <- utility.generation(utility.matrix, 0.5, 0.7, 10, 0.3, 0.6, 0.2, 1)
p2 <- utility.generation(utility.matrix, 0.1, 1, 25, 0, 1, 0.5, 1.5)
p3 <- utility.generation(utility.matrix, -0.2, 0.5, 30, -0.5, 1, 0.3, 1)
p4 <- utility.generation(utility.matrix, 0.1, -0.5, -10, -0.4, 0, -0.2, -0.3)

p1.utility <- utility.calculation(ut.matrix, p1[[1]], p1[[2]], p1[[3]]*150, p1[[4]], p1[[5]], p1[[6]], p1[[7]], p1[[8]])%>%
  dplyr::select(id, utility)
p2.utility <- utility.calculation(ut.matrix, p2[[1]], p2[[2]], p2[[3]]*150, p2[[4]], p2[[5]], p2[[6]], p2[[7]], p2[[8]])%>%
  dplyr::select(id, utility)
p3.utility <- utility.calculation(ut.matrix, p3[[1]], p3[[2]], p3[[3]]*150, p3[[4]], p3[[5]], p3[[6]], p3[[7]], p3[[8]])%>%
  dplyr::select(id, utility)
p4.utility <- utility.calculation(ut.matrix, p4[[1]], p4[[2]], p4[[3]]*150, p4[[4]], p4[[5]], p4[[6]], p4[[7]], p4[[8]])%>%
  dplyr::select(id, utility)

group.utility <- ut.matrix%>%
  inner_join(p1.utility, by = "id")%>%
  inner_join(p2.utility, by = "id")%>%
  inner_join(p3.utility, by = "id")%>%
  inner_join(p4.utility, by = "id")

colnames(group.utility) <- c("nuc.power1", "nuc.power2", "CO2Price", "ban.fuel.explore1", "ban.fuel.explore2", "RFS1", "RFS2", "id", "p1.utility", "p2.utility", "p3.utility", "p4.utility")

group.utility <- group.utility%>%
  mutate(group.score = (0.25*p1.utility + 0.25*p2.utility + 0.25 * p3.utility + 0.25 * p4.utility))%>%
  arrange(desc(group.score))

group.recommendation <- function(t){
  
  
  new.data <- group.utility[c(1, sample(2:162, 1)),]
  new.data <- new.data%>%
    mutate(p1.vote = exp(p1.utility)/(1+exp(p1.utility)))%>%
    mutate(p2.vote = exp(p2.utility)/(1+exp(p2.utility)))%>%
    mutate(p3.vote = exp(p3.utility)/(1+exp(p3.utility)))%>%
    mutate(p4.vote = exp(p4.utility)/(1+exp(p4.utility)))%>%
    mutate(p1.choice = as.numeric(rbinom(n(), 1, p1.vote)))%>%
    mutate(p2.choice = as.numeric(rbinom(n(), 1, p2.vote)))%>%
    mutate(p3.choice = as.numeric(rbinom(n(), 1, p3.vote)))%>%
    mutate(p4.choice = as.numeric(rbinom(n(), 1, p4.vote)))

  
  u.diagnostic <- c()
  u.ranking <- c()
  u.id <- c()
  
  all.utility <- c()
  all.covmat <- c()
  all.models <- c()
  
  for (j in 2:t){
    
    id.chosen <- new.data$id
    
    outcome.choice <- as.matrix(new.data[,c("p1.choice", "p2.choice", "p3.choice", "p4.choice")])
    
    o.choice <- as.data.frame(outcome.choice)%>%
      mutate(yes = p1.choice + p2.choice + p3.choice + p4.choice)%>%
      mutate(no = 4 - yes)%>%
      dplyr::select(yes, no)
    
    o.choice <- as.matrix(o.choice)
    
    p1.ut <- group.utility$p1.utility
    p2.ut <- group.utility$p2.utility
    p3.ut <- group.utility$p3.utility
    p4.ut <- group.utility$p4.utility
    
    m1.model <- stan_glm(formula = o.choice ~ 1 + (p1.utility) + (p2.utility) + (p3.utility) + (p4.utility), data = new.data, family = binomial(), 
                         prior = normal())
    
    all.models[[j]] <- m1.model$coefficients
    
    all.covmat[[j]] <- m1.model$covmat
    
    coef.model <- m1.model$coefficients
    
    var.model <- diag(m1.model$covmat)
    
    
    var.left <- p1.ut^2*var.model[2]+p2.ut^2*var.model[3] + p3.ut^2 * var.model[4] + p4.ut^2 * var.model[5]
    
    var.right <- p1.ut*p2.ut*m1.model$covmat[2, 3] + p1.ut*p3.ut*m1.model$covmat[2, 4] + p1.ut * p4.ut * m1.model$covmat[2, 5] +
      p2.ut*p3.ut*m1.model$covmat[3, 4] + p2.ut*p4.ut*m1.model$covmat[3, 5] + p3.ut*p4.ut * m1.model$covmat[4, 5]
    
    var.total <- var.left + var.right
    
    people.utility <- group.utility[, 9:12]
    
    mean.total <- as.matrix(people.utility)%*%m1.model$coefficients[2:5]
    
    beta.init <- 2* log((4*j^2*pi^2)/(6))
    
    new.utility <- as.data.frame(cbind(group.utility, var.total, mean.total))%>%
      mutate(new.utilities = mean.total + sqrt(beta.init)*sqrt(var.total))
    
    
    max.utility.row <- which.max(new.utility$new.utilities)
    
    # for (i in 1:length(id.chosen)){
    #   
    #   if (id.chosen[i] == new.utility$id[max.utility.row]){
    #     counter <- counter + 1
    #     
    #   }
    #   else{
    #     counter <- counter + 0
    #   }
    # }
    # 
    new.ranking <- new.utility%>%
      arrange(desc(new.utilities))
    
    new.alt.id <- new.ranking$id[1]
    new.alt <- group.utility%>%
      dplyr::filter(id == new.alt.id)
    
    u.id[j] <- new.alt.id
    u.diagnostic[j] <- new.ranking$new.utility[1]
    u.ranking[j] <- which(new.ranking$id == new.alt.id)
  
    
    new.alter <- new.alt%>%
      mutate(p1.vote = exp(p1.utility)/(1+exp(p1.utility)))%>%
      mutate(p2.vote = exp(p2.utility)/(1+exp(p2.utility)))%>%
      mutate(p3.vote = exp(p3.utility)/(1+exp(p3.utility)))%>%
      mutate(p4.vote = exp(p4.utility)/(1+exp(p4.utility)))%>%
      mutate(p1.choice = as.numeric(rbinom(n(), 1, p1.vote)))%>%
      mutate(p2.choice = as.numeric(rbinom(n(), 1, p2.vote)))%>%
      mutate(p3.choice = as.numeric(rbinom(n(), 1, p3.vote)))%>%
      mutate(p4.choice = as.numeric(rbinom(n(), 1, p4.vote)))
    
    new.data <- rbind(new.data, new.alter)
    
    iteration.vector <- rep(j, 162)
    
    diag.util <- cbind(new.utility, iteration.vector)
    
    if(j == 2){
      
      all.utility <- diag.util
      
    }
    else{
      
      all.utility <- rbind(all.utility, diag.util)
      
    }

    
  }
  
  
  my.list <- list(new.data, all.models, all.covmat, counter, id.chosen, new.utility, u.id, u.ranking, u.diagnostic, all.utility)
  
  return(my.list)

  }

a.test <- group.recommendation(15)

a.tesiteration.2 <- a.test[[9]]%>%
  filter(iteration.vector == 2)

iteration.3 <- a.test[[9]]%>%
  filter(iteration.vector == 3)

iteration.4 <- a.test[[9]]%>%
  filter(iteration.vector == 4)

ppl.utility <- a.test[[5]]%>%
  dplyr::select(p1.utility, p2.utility, p3.utility, p4.utility)

estimated.mean <- as.matrix(ppl.utility)%*%a.test[[2]]$coefficients[2:5]

est.var <- a.test[[5]]$var.total

t.var <- sqrt(a)*sqrt(est.var)

actual.mean <- a.test[[5]]$group.score

cor.test1 <- cbind(actual.mean, estimated.mean)

group.recommendation.constantdelta <- function(t){
  
  
  new.data <- group.utility[c(1, sample(2:162, 1)),]
  new.data <- new.data%>%
    mutate(p1.vote = exp(p1.utility)/(1+exp(p1.utility)))%>%
    mutate(p2.vote = exp(p2.utility)/(1+exp(p2.utility)))%>%
    mutate(p3.vote = exp(p3.utility)/(1+exp(p3.utility)))%>%
    mutate(p4.vote = exp(p4.utility)/(1+exp(p4.utility)))%>%
    mutate(p1.choice = as.numeric(rbinom(n(), 1, p1.vote)))%>%
    mutate(p2.choice = as.numeric(rbinom(n(), 1, p2.vote)))%>%
    mutate(p3.choice = as.numeric(rbinom(n(), 1, p3.vote)))%>%
    mutate(p4.choice = as.numeric(rbinom(n(), 1, p4.vote)))
  
  
  u.diagnostic <- c()
  u.ranking <- c()
  u.id <- c()
  
  all.utility <- c()
  all.models <- c()
  
  for (j in 2:t){
    
    id.chosen <- new.data$id
    
    outcome.choice <- as.matrix(new.data[,c("p1.choice", "p2.choice", "p3.choice", "p4.choice")])
    
    o.choice <- as.data.frame(outcome.choice)%>%
      mutate(yes = p1.choice + p2.choice + p3.choice + p4.choice)%>%
      mutate(no = 4 - yes)%>%
      dplyr::select(yes, no)
    
    o.choice <- as.matrix(o.choice)
    
    p1.ut <- group.utility$p1.utility
    p2.ut <- group.utility$p2.utility
    p3.ut <- group.utility$p3.utility
    p4.ut <- group.utility$p4.utility
    
    m1.model <- stan_glm(formula = o.choice ~ 1 + (p1.utility) + (p2.utility) + (p3.utility) + (p4.utility), data = new.data, family = binomial(), 
                         prior = normal())
    
    all.models[[j]] <- m1.model$coefficients
    var.model <- diag(m1.model$covmat)
    
    var.left <- p1.ut^2*var.model[2]+p2.ut^2*var.model[3] + p3.ut^2 * var.model[4] + p4.ut^2 * var.model[5]
    
    var.right <- p1.ut*p2.ut*m1.model$covmat[2, 3] + p1.ut*p3.ut*m1.model$covmat[2, 4] + p1.ut * p4.ut * m1.model$covmat[2, 5] +
      p2.ut*p3.ut*m1.model$covmat[3, 4] + p2.ut*p4.ut*m1.model$covmat[3, 5] + p3.ut*p4.ut * m1.model$covmat[4, 5]
    
    var.total <- var.left + var.right
    
    people.utility <- group.utility[, 9:12]
    
    mean.total <- as.matrix(people.utility)%*%m1.model$coefficients[2:5]
    
    beta.init <- 2* log((4*0.5*pi^2)/(6))
    
    new.utility <- as.data.frame(cbind(group.utility, var.total, mean.total))%>%
      mutate(new.utility = mean.total + sqrt(beta.init)*sqrt(var.total))
    
    
    max.utility.row <- which.max(new.utility$new.utility)
    
    # for (i in 1:length(id.chosen)){
    #   
    #   if (id.chosen[i] == new.utility$id[max.utility.row]){
    #     counter <- counter + 1
    #     
    #   }
    #   else{
    #     counter <- counter + 0
    #   }
    # }
    # 
    new.ranking <- new.utility%>%
      arrange(desc(new.utility))
    
    new.alt.id <- new.ranking$id[1]
    new.alt <- group.utility%>%
      dplyr::filter(id == new.alt.id)
    
    u.id[j] <- new.alt.id
    u.diagnostic[j] <- new.ranking$new.utility[1]
    u.ranking[j] <- which(new.ranking$id == new.alt.id)
    
    
    new.alter <- new.alt%>%
      mutate(p1.vote = exp(p1.utility)/(1+exp(p1.utility)))%>%
      mutate(p2.vote = exp(p2.utility)/(1+exp(p2.utility)))%>%
      mutate(p3.vote = exp(p3.utility)/(1+exp(p3.utility)))%>%
      mutate(p4.vote = exp(p4.utility)/(1+exp(p4.utility)))%>%
      mutate(p1.choice = as.numeric(rbinom(n(), 1, p1.vote)))%>%
      mutate(p2.choice = as.numeric(rbinom(n(), 1, p2.vote)))%>%
      mutate(p3.choice = as.numeric(rbinom(n(), 1, p3.vote)))%>%
      mutate(p4.choice = as.numeric(rbinom(n(), 1, p4.vote)))
    
    new.data <- rbind(new.data, new.alter)
    
    iteration.vector <- rep(j, 162)
    
    diag.util <- cbind(new.utility, iteration.vector)
    
    if(j == 2){
      
      all.utility <- diag.util
      
    }
    else{
      
      all.utility <- rbind(all.utility, diag.util)
      
    }
    
    
  }
  
  
  my.list <- list(new.data, all.models, counter, id.chosen, new.utility, u.id, u.ranking, u.diagnostic, all.utility)
  
  return(my.list)
  
}

test.3 <- group.recommendation.constantdelta(15)

test.4 <- group.recommendation.constantdelta(30)

test.5 <- group.recommendation(30)

group.recommendation.norepeat <- function(t){
  
  
  new.data <- group.utility[c(1, sample(2:162, 1)),]
  new.data <- new.data%>%
    mutate(p1.vote = exp(p1.utility)/(1+exp(p1.utility)))%>%
    mutate(p2.vote = exp(p2.utility)/(1+exp(p2.utility)))%>%
    mutate(p3.vote = exp(p3.utility)/(1+exp(p3.utility)))%>%
    mutate(p4.vote = exp(p4.utility)/(1+exp(p4.utility)))%>%
    mutate(p1.choice = as.numeric(rbinom(n(), 1, p1.vote)))%>%
    mutate(p2.choice = as.numeric(rbinom(n(), 1, p2.vote)))%>%
    mutate(p3.choice = as.numeric(rbinom(n(), 1, p3.vote)))%>%
    mutate(p4.choice = as.numeric(rbinom(n(), 1, p4.vote)))
  
  
  u.diagnostic <- c()
  u.ranking <- c()
  u.id <- c()
  
  all.utility <- c()
  
  for (j in 2:t){
    
    id.chosen <- new.data$id
    
    outcome.choice <- as.matrix(new.data[,c("p1.choice", "p2.choice", "p3.choice", "p4.choice")])
    
    o.choice <- as.data.frame(outcome.choice)%>%
      mutate(yes = p1.choice + p2.choice + p3.choice + p4.choice)%>%
      mutate(no = 4 - yes)%>%
      dplyr::select(yes, no)
    
    o.choice <- as.matrix(o.choice)
    
    p1.ut <- group.utility$p1.utility
    p2.ut <- group.utility$p2.utility
    p3.ut <- group.utility$p3.utility
    p4.ut <- group.utility$p4.utility
    
    m1.model <- stan_glm(formula = o.choice ~ 1 + (p1.utility) + (p2.utility) + (p3.utility) + (p4.utility), data = new.data, family = binomial(), 
                         prior = normal())
    
    var.model <- diag(m1.model$covmat)
    
    var.left <- p1.ut^2*var.model[2]+p2.ut^2*var.model[3] + p3.ut^2 * var.model[4] + p4.ut^2 * var.model[5]
    
    var.right <- p1.ut*p2.ut*m1.model$covmat[2, 3] + p1.ut*p3.ut*m1.model$covmat[2, 4] + p1.ut * p4.ut * m1.model$covmat[2, 5] +
      p2.ut*p3.ut*m1.model$covmat[3, 4] + p2.ut*p4.ut*m1.model$covmat[3, 5] + p3.ut*p4.ut * m1.model$covmat[4, 5]
    
    var.total <- var.left + var.right
    
    people.utility <- group.utility[, 9:12]
    
    mean.total <- as.matrix(people.utility)%*%m1.model$coefficients[2:5]
    
    beta.init <- 2* log((4*j^2*pi^2)/(6))
    
    new.utility <- as.data.frame(cbind(group.utility, var.total, mean.total))%>%
      mutate(new.utility = mean.total+sqrt(beta.init)*sqrt(var.total))
    
    
    max.utility.row <- which.max(new.utility$new.utility)

    new.ranking <- new.utility%>%
      arrange(desc(new.utility))
    
    new.alt.id <- new.ranking$id[1]
    new.alt <- group.utility%>%
      dplyr::filter(id == new.alt.id)
    
    u.id[j] <- new.alt.id
    u.diagnostic[j] <- new.ranking$new.utility[1]
    u.ranking[j] <- which(new.ranking$id == new.alt.id)
    
    
    new.alter <- new.alt%>%
      mutate(p1.vote = exp(p1.utility)/(1+exp(p1.utility)))%>%
      mutate(p2.vote = exp(p2.utility)/(1+exp(p2.utility)))%>%
      mutate(p3.vote = exp(p3.utility)/(1+exp(p3.utility)))%>%
      mutate(p4.vote = exp(p4.utility)/(1+exp(p4.utility)))%>%
      mutate(p1.choice = as.numeric(rbinom(n(), 1, p1.vote)))%>%
      mutate(p2.choice = as.numeric(rbinom(n(), 1, p2.vote)))%>%
      mutate(p3.choice = as.numeric(rbinom(n(), 1, p3.vote)))%>%
      mutate(p4.choice = as.numeric(rbinom(n(), 1, p4.vote)))
    
    new.data <- rbind(new.data, new.alter)
    
    iteration.vector <- rep(j, 162)
    
    diag.util <- cbind(new.utility, iteration.vector)
    
    if(j == 2){
      
      all.utility <- diag.util
      
    }
    else{
      
      all.utility <- rbind(all.utility, diag.util)
      
    }
    
    
  }
  
  
  my.list <- list(new.data, m1.model, counter, id.chosen, new.utility, u.id, u.ranking, u.diagnostic, all.utility)
  
  return(my.list)
  
}

test.6 <- group.recommendation.norepeat(15)

View(test.6[[9]])

random.weights <- runif(4, min = 0, max =1)

#weights <- random.weights/sum(random.weights)

weights <- c(0.25, 0.25, 0.25, 0.25)

group.utility <- group.utility%>%
  mutate(group.score = (weights[1]*p1.utility + weights[2]*p2.utility + weights[3] * p3.utility + weights[4] * p4.utility))%>%
  arrange(desc(group.score))

test.7 <- group.recommendation(15)
test.8 <- group.recommendation.constantdelta(15)

test.1 <- group.recommendation(15)

group.recommendation.doptimal <- function(t){
  
  
  
  
  new.data <- group.utility[c(1),]
  
  optimal.design.matrix <- as.matrix(group.utility[8:12])
  
  doptimaldesign <- Dopt.design(5, data = optimal.design.matrix, formula = ~p1.utility + p2.utility + p3.utility + p4.utility)
  
  id.optimal <- doptimaldesign$id
  
  optimal.data <- subset(group.utility, id %in% id.optimal)
  
  new.data <- rbind(new.data, optimal.data)
  
  new.data <- new.data%>%
    mutate(p1.vote = exp(p1.utility)/(1+exp(p1.utility)))%>%
    mutate(p2.vote = exp(p2.utility)/(1+exp(p2.utility)))%>%
    mutate(p3.vote = exp(p3.utility)/(1+exp(p3.utility)))%>%
    mutate(p4.vote = exp(p4.utility)/(1+exp(p4.utility)))%>%
    mutate(p1.choice = as.numeric(rbinom(n(), 1, p1.vote)))%>%
    mutate(p2.choice = as.numeric(rbinom(n(), 1, p2.vote)))%>%
    mutate(p3.choice = as.numeric(rbinom(n(), 1, p3.vote)))%>%
    mutate(p4.choice = as.numeric(rbinom(n(), 1, p4.vote)))
  
  
  u.diagnostic <- c()
  u.ranking <- c()
  u.id <- c()
  
  all.utility <- c()
  
  model.coefficients <- c()
  
  model.fitted <- c()
  
  for (j in 6:t){
    
    id.chosen <- new.data$id
    
    outcome.choice <- as.matrix(new.data[,c("p1.choice", "p2.choice", "p3.choice", "p4.choice")])
    
    o.choice <- as.data.frame(outcome.choice)%>%
      mutate(yes = p1.choice + p2.choice + p3.choice + p4.choice)%>%
      mutate(no = 4 - yes)%>%
      dplyr::select(yes, no)
    
    o.choice <- as.matrix(o.choice)
    
    p1.ut <- group.utility$p1.utility
    p2.ut <- group.utility$p2.utility
    p3.ut <- group.utility$p3.utility
    p4.ut <- group.utility$p4.utility
    
    m1.model <- stan_glm(formula = o.choice ~ 1 + (p1.utility) + (p2.utility) + (p3.utility) + (p4.utility), data = new.data, family = binomial(), 
                         prior = normal())
    
    model.coefficients[[j]] <- m1.model$coefficients
    
    model.fitted[[j]] <- m1.model$covmat
    
    var.model <- diag(m1.model$covmat)
    
    var.left <- p1.ut^2*var.model[2]+p2.ut^2*var.model[3] + p3.ut^2 * var.model[4] + p4.ut^2 * var.model[5]
    
    var.right <- p1.ut*p2.ut*m1.model$covmat[2, 3] + p1.ut*p3.ut*m1.model$covmat[2, 4] + p1.ut * p4.ut * m1.model$covmat[2, 5] +
      p2.ut*p3.ut*m1.model$covmat[3, 4] + p2.ut*p4.ut*m1.model$covmat[3, 5] + p3.ut*p4.ut * m1.model$covmat[4, 5]
    
    var.total <- var.left + var.right
    
    people.utility <- group.utility[, 9:12]
    
    mean.total <- as.matrix(people.utility)%*%m1.model$coefficients[2:5]
    
    beta.init <- 2* log((4*j^2*pi^2)/(6))
    
    new.utility <- as.data.frame(cbind(group.utility, var.total, mean.total))%>%
      mutate(new.utility = mean.total+sqrt(beta.init)*sqrt(var.total))
    
    
    max.utility.row <- which.max(new.utility$new.utility)
    
    new.ranking <- new.utility%>%
      arrange(desc(new.utility))
    
    new.alt.id <- new.ranking$id[1]
    
    new.alt <- group.utility%>%
      dplyr::filter(id == new.alt.id)
    
    u.id[j] <- new.alt.id
    u.diagnostic[j] <- new.ranking$new.utility[1]
    u.ranking[j] <- which(new.ranking$id == new.alt.id)
    
    
    new.alter <- new.alt%>%
      mutate(p1.vote = exp(p1.utility)/(1+exp(p1.utility)))%>%
      mutate(p2.vote = exp(p2.utility)/(1+exp(p2.utility)))%>%
      mutate(p3.vote = exp(p3.utility)/(1+exp(p3.utility)))%>%
      mutate(p4.vote = exp(p4.utility)/(1+exp(p4.utility)))%>%
      mutate(p1.choice = as.numeric(rbinom(n(), 1, p1.vote)))%>%
      mutate(p2.choice = as.numeric(rbinom(n(), 1, p2.vote)))%>%
      mutate(p3.choice = as.numeric(rbinom(n(), 1, p3.vote)))%>%
      mutate(p4.choice = as.numeric(rbinom(n(), 1, p4.vote)))
    
    new.data <- rbind(new.data, new.alter)
    
    iteration.vector <- rep(j, 162)
    
    diag.util <- cbind(new.utility, iteration.vector)
    
    if(j == 6){
      
      all.utility <- diag.util
      
    }
    else{
      
      all.utility <- rbind(all.utility, diag.util)
      
    }
    
    
  }
  
  
  my.list <- list(new.data, model.coefficients, model.fitted, counter, id.chosen, new.utility, u.id, u.ranking, u.diagnostic, all.utility)
  
  return(my.list)
  
}

test.10 <- group.recommendation.doptimal(15)


group.recommendation.doptimalonly <- function(t){
  

  new.data <- group.utility
  optimal.design.matrix <- as.matrix(group.utility[8:12])
  
  doptimaldesign <- Dopt.design(t, data = optimal.design.matrix, formula = ~p1.utility + p2.utility + p3.utility + p4.utility)
  
  id.optimal <- doptimaldesign$id
  
  optimal.data <- subset(group.utility, id %in% id.optimal)
  
  new.data <- optimal.data%>%
    mutate(p1.vote = exp(p1.utility)/(1+exp(p1.utility)))%>%
    mutate(p2.vote = exp(p2.utility)/(1+exp(p2.utility)))%>%
    mutate(p3.vote = exp(p3.utility)/(1+exp(p3.utility)))%>%
    mutate(p4.vote = exp(p4.utility)/(1+exp(p4.utility)))%>%
    mutate(p1.choice = as.numeric(rbinom(n(), 1, p1.vote)))%>%
    mutate(p2.choice = as.numeric(rbinom(n(), 1, p2.vote)))%>%
    mutate(p3.choice = as.numeric(rbinom(n(), 1, p3.vote)))%>%
    mutate(p4.choice = as.numeric(rbinom(n(), 1, p4.vote)))
  
  
  outcome.choice <- as.matrix(new.data[,c("p1.choice", "p2.choice", "p3.choice", "p4.choice")])
  
  o.choice <- as.data.frame(outcome.choice)%>%
    mutate(yes = p1.choice + p2.choice + p3.choice + p4.choice)%>%
    mutate(no = 4 - yes)%>%
    dplyr::select(yes, no)
  
  o.choice <- as.matrix(o.choice)
  
  m1.model <- stan_glm(formula = o.choice ~ 1 + (p1.utility) + (p2.utility) + (p3.utility) + (p4.utility), data = new.data, family = binomial(), 
                       prior = normal())
  
  all.models[[j]] <- m1.model$coefficients
  all.covmat[[j]] <- m1.model$covmat
 
  
  my.list <- list(new.data, model.coefficients, model.fitted, m1.model)
  
  return(my.list)
  
}

#d-optimal design
test.11 <- group.recommendation.doptimalonly(15)

group.recommendation.hybrid <- function(t){
  
  all.models <- c()
  all.covmat <- c()
  
  new.data <- group.utility
  optimal.design.matrix <- as.matrix(group.utility[8:12])
  
  doptimaldesign <- Dopt.design(t-5, data = optimal.design.matrix, formula = ~p1.utility + p2.utility + p3.utility + p4.utility)
  
  id.optimal <- doptimaldesign$id
  
  optimal.data <- subset(group.utility, id %in% id.optimal)
  
  new.data <- optimal.data%>%
    mutate(p1.vote = exp(p1.utility)/(1+exp(p1.utility)))%>%
    mutate(p2.vote = exp(p2.utility)/(1+exp(p2.utility)))%>%
    mutate(p3.vote = exp(p3.utility)/(1+exp(p3.utility)))%>%
    mutate(p4.vote = exp(p4.utility)/(1+exp(p4.utility)))%>%
    mutate(p1.choice = as.numeric(rbinom(n(), 1, p1.vote)))%>%
    mutate(p2.choice = as.numeric(rbinom(n(), 1, p2.vote)))%>%
    mutate(p3.choice = as.numeric(rbinom(n(), 1, p3.vote)))%>%
    mutate(p4.choice = as.numeric(rbinom(n(), 1, p4.vote)))
  
  
  outcome.choice <- as.matrix(new.data[,c("p1.choice", "p2.choice", "p3.choice", "p4.choice")])
  
  o.choice <- as.data.frame(outcome.choice)%>%
    mutate(yes = p1.choice + p2.choice + p3.choice + p4.choice)%>%
    mutate(no = 4 - yes)%>%
    dplyr::select(yes, no)
  
  o.choice <- as.matrix(o.choice)
  
  m1.model <- stan_glm(formula = o.choice ~ 1 + (p1.utility) + (p2.utility) + (p3.utility) + (p4.utility), data = new.data, family = binomial(), 
                       prior = normal())
  
  
  
  for (j in 11:t){
    
    u.diagnostic <- c()
    u.ranking <- c()
    u.id <- c()
    
    all.utility <- c()
    all.models <- c()
    
    id.chosen <- new.data$id
    
    outcome.choice <- as.matrix(new.data[,c("p1.choice", "p2.choice", "p3.choice", "p4.choice")])
    
    o.choice <- as.data.frame(outcome.choice)%>%
      mutate(yes = p1.choice + p2.choice + p3.choice + p4.choice)%>%
      mutate(no = 4 - yes)%>%
      dplyr::select(yes, no)
    
    o.choice <- as.matrix(o.choice)
    
    p1.ut <- group.utility$p1.utility
    p2.ut <- group.utility$p2.utility
    p3.ut <- group.utility$p3.utility
    p4.ut <- group.utility$p4.utility
    
    m1.model <- stan_glm(formula = o.choice ~ 1 + (p1.utility) + (p2.utility) + (p3.utility) + (p4.utility), data = new.data, family = binomial(), 
                         prior = normal())
    
    var.left <- p1.ut^2*var.model[2]+p2.ut^2*var.model[3] + p3.ut^2 * var.model[4] + p4.ut^2 * var.model[5]
    
    var.right <- p1.ut*p2.ut*m1.model$covmat[2, 3] + p1.ut*p3.ut*m1.model$covmat[2, 4] + p1.ut * p4.ut * m1.model$covmat[2, 5] +
      p2.ut*p3.ut*m1.model$covmat[3, 4] + p2.ut*p4.ut*m1.model$covmat[3, 5] + p3.ut*p4.ut * m1.model$covmat[4, 5]
    
    var.total <- var.left + var.right
    
    people.utility <- group.utility[, 9:12]
    
    mean.total <- as.matrix(people.utility)%*%m1.model$coefficients[2:5]
    
    beta.init <- 2* log((4*j*pi^2)/(6))
    
    new.utility <- as.data.frame(cbind(group.utility, var.total, mean.total))%>%
      mutate(new.utility = mean.total + sqrt(beta.init)*sqrt(var.total))
    
    
    max.utility.row <- which.max(new.utility$new.utility)
    
    new.ranking <- new.utility%>%
      arrange(desc(new.utility))
    
    new.alt.id <- new.ranking$id[1]
    new.alt <- group.utility%>%
      dplyr::filter(id == new.alt.id)
    
    
    new.alter <- new.alt%>%
      mutate(p1.vote = exp(p1.utility)/(1+exp(p1.utility)))%>%
      mutate(p2.vote = exp(p2.utility)/(1+exp(p2.utility)))%>%
      mutate(p3.vote = exp(p3.utility)/(1+exp(p3.utility)))%>%
      mutate(p4.vote = exp(p4.utility)/(1+exp(p4.utility)))%>%
      mutate(p1.choice = as.numeric(rbinom(n(), 1, p1.vote)))%>%
      mutate(p2.choice = as.numeric(rbinom(n(), 1, p2.vote)))%>%
      mutate(p3.choice = as.numeric(rbinom(n(), 1, p3.vote)))%>%
      mutate(p4.choice = as.numeric(rbinom(n(), 1, p4.vote)))
    
    new.data <- rbind(new.data, new.alter)
    
    
  }
  
  my.list <- list(new.data, m1.model$coefficients)
  
  return(my.list)
  
}

test.20 <- group.recommendation.hybrid(15)

group.recommendation.hybrid2 <- function(t){
  
  all.models <- c()
  all.covmat <- c()
  
  new.data <- group.utility
  optimal.design.matrix <- as.matrix(group.utility[8:12])
  
  doptimaldesign <- Dopt.design(t-2, data = optimal.design.matrix, formula = ~p1.utility + p2.utility + p3.utility + p4.utility)
  
  id.optimal <- doptimaldesign$id
  
  optimal.data <- subset(group.utility, id %in% id.optimal)
  
  new.data <- optimal.data%>%
    mutate(p1.vote = exp(p1.utility)/(1+exp(p1.utility)))%>%
    mutate(p2.vote = exp(p2.utility)/(1+exp(p2.utility)))%>%
    mutate(p3.vote = exp(p3.utility)/(1+exp(p3.utility)))%>%
    mutate(p4.vote = exp(p4.utility)/(1+exp(p4.utility)))%>%
    mutate(p1.choice = as.numeric(rbinom(n(), 1, p1.vote)))%>%
    mutate(p2.choice = as.numeric(rbinom(n(), 1, p2.vote)))%>%
    mutate(p3.choice = as.numeric(rbinom(n(), 1, p3.vote)))%>%
    mutate(p4.choice = as.numeric(rbinom(n(), 1, p4.vote)))
  
  
  outcome.choice <- as.matrix(new.data[,c("p1.choice", "p2.choice", "p3.choice", "p4.choice")])
  
  o.choice <- as.data.frame(outcome.choice)%>%
    mutate(yes = p1.choice + p2.choice + p3.choice + p4.choice)%>%
    mutate(no = 4 - yes)%>%
    dplyr::select(yes, no)
  
  o.choice <- as.matrix(o.choice)
  
  m1.model <- stan_glm(formula = o.choice ~ 1 + (p1.utility) + (p2.utility) + (p3.utility) + (p4.utility), data = new.data, family = binomial(), 
                       prior = normal())
  
  
  
  for (j in 14:t){
    
    u.diagnostic <- c()
    u.ranking <- c()
    u.id <- c()
    
    all.utility <- c()
    all.models <- c()
    
    id.chosen <- new.data$id
    
    outcome.choice <- as.matrix(new.data[,c("p1.choice", "p2.choice", "p3.choice", "p4.choice")])
    
    o.choice <- as.data.frame(outcome.choice)%>%
      mutate(yes = p1.choice + p2.choice + p3.choice + p4.choice)%>%
      mutate(no = 4 - yes)%>%
      dplyr::select(yes, no)
    
    o.choice <- as.matrix(o.choice)
    
    p1.ut <- group.utility$p1.utility
    p2.ut <- group.utility$p2.utility
    p3.ut <- group.utility$p3.utility
    p4.ut <- group.utility$p4.utility
    
    m1.model <- stan_glm(formula = o.choice ~ 1 + (p1.utility) + (p2.utility) + (p3.utility) + (p4.utility), data = new.data, family = binomial(), 
                         prior = normal())
    
    var.left <- p1.ut^2*var.model[2]+p2.ut^2*var.model[3] + p3.ut^2 * var.model[4] + p4.ut^2 * var.model[5]
    
    var.right <- p1.ut*p2.ut*m1.model$covmat[2, 3] + p1.ut*p3.ut*m1.model$covmat[2, 4] + p1.ut * p4.ut * m1.model$covmat[2, 5] +
      p2.ut*p3.ut*m1.model$covmat[3, 4] + p2.ut*p4.ut*m1.model$covmat[3, 5] + p3.ut*p4.ut * m1.model$covmat[4, 5]
    
    var.total <- var.left + var.right
    
    people.utility <- group.utility[, 9:12]
    
    mean.total <- as.matrix(people.utility)%*%m1.model$coefficients[2:5]
    
    beta.init <- 2* log((4*j*pi^2)/(6))
    
    new.utility <- as.data.frame(cbind(group.utility, var.total, mean.total))%>%
      mutate(new.utility = mean.total + sqrt(beta.init)*sqrt(var.total))
    
    
    max.utility.row <- which.max(new.utility$new.utility)
    
    new.ranking <- new.utility%>%
      arrange(desc(new.utility))
    
    new.alt.id <- new.ranking$id[1]
    new.alt <- group.utility%>%
      dplyr::filter(id == new.alt.id)
    
    
    new.alter <- new.alt%>%
      mutate(p1.vote = exp(p1.utility)/(1+exp(p1.utility)))%>%
      mutate(p2.vote = exp(p2.utility)/(1+exp(p2.utility)))%>%
      mutate(p3.vote = exp(p3.utility)/(1+exp(p3.utility)))%>%
      mutate(p4.vote = exp(p4.utility)/(1+exp(p4.utility)))%>%
      mutate(p1.choice = as.numeric(rbinom(n(), 1, p1.vote)))%>%
      mutate(p2.choice = as.numeric(rbinom(n(), 1, p2.vote)))%>%
      mutate(p3.choice = as.numeric(rbinom(n(), 1, p3.vote)))%>%
      mutate(p4.choice = as.numeric(rbinom(n(), 1, p4.vote)))
    
    new.data <- rbind(new.data, new.alter)
    
    
  }
  
  my.list <- list(new.data, m1.model$coefficients)
  
  return(my.list)
  
}

group.recommendation.random <- function(t){
  
  new.data <- group.utility[c(1, sample(2:162, 14)),]
  new.data <- new.data%>%
    mutate(p1.vote = exp(p1.utility)/(1+exp(p1.utility)))%>%
    mutate(p2.vote = exp(p2.utility)/(1+exp(p2.utility)))%>%
    mutate(p3.vote = exp(p3.utility)/(1+exp(p3.utility)))%>%
    mutate(p4.vote = exp(p4.utility)/(1+exp(p4.utility)))%>%
    mutate(p1.choice = as.numeric(rbinom(n(), 1, p1.vote)))%>%
    mutate(p2.choice = as.numeric(rbinom(n(), 1, p2.vote)))%>%
    mutate(p3.choice = as.numeric(rbinom(n(), 1, p3.vote)))%>%
    mutate(p4.choice = as.numeric(rbinom(n(), 1, p4.vote)))
  
  
  u.diagnostic <- c()
  u.ranking <- c()
  u.id <- c()
  
  all.utility <- c()
  all.models <- c()
  all.covmat <- c()
  
  for (j in 2:t){
    
    id.chosen <- new.data$id
    
    outcome.choice <- as.matrix(new.data[,c("p1.choice", "p2.choice", "p3.choice", "p4.choice")])
    
    o.choice <- as.data.frame(outcome.choice)%>%
      mutate(yes = p1.choice + p2.choice + p3.choice + p4.choice)%>%
      mutate(no = 4 - yes)%>%
      dplyr::select(yes, no)
    
    o.choice <- as.matrix(o.choice)
    
    p1.ut <- group.utility$p1.utility
    p2.ut <- group.utility$p2.utility
    p3.ut <- group.utility$p3.utility
    p4.ut <- group.utility$p4.utility
    
    m1.model <- stan_glm(formula = o.choice ~ 1 + (p1.utility) + (p2.utility) + (p3.utility) + (p4.utility), data = new.data, family = binomial(), 
                         prior = normal())
    
    all.models[[j]] <- m1.model$coefficients
    all.covmat[[j]] <- m1.model$covmat
    
    new.alt.id <- sample(1:162, 1)
    new.alt <- group.utility%>%
      dplyr::filter(id == new.alt.id)
    
    u.id[j] <- new.alt.id
    u.diagnostic[j] <- new.ranking$new.utility[1]
    u.ranking[j] <- which(new.ranking$id == new.alt.id)
    
    
    new.alter <- new.alt%>%
      mutate(p1.vote = exp(p1.utility)/(1+exp(p1.utility)))%>%
      mutate(p2.vote = exp(p2.utility)/(1+exp(p2.utility)))%>%
      mutate(p3.vote = exp(p3.utility)/(1+exp(p3.utility)))%>%
      mutate(p4.vote = exp(p4.utility)/(1+exp(p4.utility)))%>%
      mutate(p1.choice = as.numeric(rbinom(n(), 1, p1.vote)))%>%
      mutate(p2.choice = as.numeric(rbinom(n(), 1, p2.vote)))%>%
      mutate(p3.choice = as.numeric(rbinom(n(), 1, p3.vote)))%>%
      mutate(p4.choice = as.numeric(rbinom(n(), 1, p4.vote)))
    
    new.data <- rbind(new.data, new.alter)
    
    iteration.vector <- rep(j, 162)
    
    diag.util <- cbind(new.utility, iteration.vector)
    
    if(j == 2){
      
      all.utility <- diag.util
      
    }
    else{
      
      all.utility <- rbind(all.utility, diag.util)
      
    }
    
    
  }
  
  
  my.list <- list(new.data, all.models, all.covmat, counter, id.chosen, new.utility, u.id, u.ranking, u.diagnostic, all.utility)
  
  return(my.list)
  
  
}

test.12 <- group.recommendation.random(15)

random.ranking <- as.matrix(people.utility)%*%as.matrix(test.12[2][[1]][[15]][2:5])

cor(random.ranking, group.utility$group.score)

test.13 <- group.recommendation(15)

group.recommendation.doptimalone <- function(t){
  
  
  new.data <- group.utility
  optimal.design.matrix <- as.matrix(group.utility[8:12])
  
  doptimaldesign <- Dopt.design(t, data = optimal.design.matrix, formula = ~p1.utility + p2.utility + p3.utility + p4.utility)
  
  id.optimal <- doptimaldesign$id
  
  optimal.data <- subset(group.utility, id %in% id.optimal)
  
  n.data <- new.data[c(1,2),]

  n.data <- optimal.data%>%
    mutate(p1.vote = exp(p1.utility)/(1+exp(p1.utility)))%>%
    mutate(p2.vote = exp(p2.utility)/(1+exp(p2.utility)))%>%
    mutate(p3.vote = exp(p3.utility)/(1+exp(p3.utility)))%>%
    mutate(p4.vote = exp(p4.utility)/(1+exp(p4.utility)))%>%
    mutate(p1.choice = as.numeric(rbinom(n(), 1, p1.vote)))%>%
    mutate(p2.choice = as.numeric(rbinom(n(), 1, p2.vote)))%>%
    mutate(p3.choice = as.numeric(rbinom(n(), 1, p3.vote)))%>%
    mutate(p4.choice = as.numeric(rbinom(n(), 1, p4.vote)))
  
  
  all.coefs <- c()
  
  all.covmat <- c()
    
  
  for(j in 3:t){
    
    outcome.choice <- as.matrix(n.data[,c("p1.choice", "p2.choice", "p3.choice", "p4.choice")])
    
    o.choice <- as.data.frame(outcome.choice)%>%
      mutate(yes = p1.choice + p2.choice + p3.choice + p4.choice)%>%
      mutate(no = 4 - yes)%>%
      dplyr::select(yes, no)
    
    
    o.choice <- as.matrix(o.choice)
    
    m1.model <- stan_glm(formula = o.choice ~ 1 + (p1.utility) + (p2.utility) + (p3.utility) + (p4.utility), data = n.data, family = binomial(), 
                         prior = normal())
    
    all.coefs[[j]] <- m1.model$coefficients

    all.covmat[[j]] <- m1.model$covmat
        
    new.alt <- new.data[j,]
    
    new.alter <- new.alt%>%
      mutate(p1.vote = exp(p1.utility)/(1+exp(p1.utility)))%>%
      mutate(p2.vote = exp(p2.utility)/(1+exp(p2.utility)))%>%
      mutate(p3.vote = exp(p3.utility)/(1+exp(p3.utility)))%>%
      mutate(p4.vote = exp(p4.utility)/(1+exp(p4.utility)))%>%
      mutate(p1.choice = as.numeric(rbinom(n(), 1, p1.vote)))%>%
      mutate(p2.choice = as.numeric(rbinom(n(), 1, p2.vote)))%>%
      mutate(p3.choice = as.numeric(rbinom(n(), 1, p3.vote)))%>%
      mutate(p4.choice = as.numeric(rbinom(n(), 1, p4.vote)))
    
    n.data <- rbind(n.data, new.alter)
    
  }
  
  
  model.coefficients <- m1.model$coefficients
  
  model.fitted <- m1.model$covmat
  
  
  
  my.list <- list(n.data, all.coefs, all.covmat)
  
  return(my.list)
  
}

doptimal.ranking <- as.matrix(people.utility)%*%as.matrix(test.11[2][[1]][2:5])

cor(doptimal.ranking, group.utility$group.score)

test.14 <- group.recommendation.doptimalone(15)


random.group.search <- function(nruns, t){
  
  correlation <- c()
  regret <- c()
  
  for(i in 1:nruns){
    
    random.search <- group.recommendation.random(t)
    
    random.ranking <- as.matrix(people.utility)%*%as.matrix(random.search[2][[1]][[15]][2:5])
    
    correlation[i] <- cor(random.ranking, group.utility$group.score)
    
    print(correlation)
    
    group.utility1 <- group.utility%>%
      mutate(new.score = random.search[2][[1]][[15]][2]*p1.utility + random.search[2][[1]][[15]][3]*p2.utility + random.search[2][[1]][[15]][4] * p3.utility 
             + random.search[2][[1]][[15]][5] * p4.utility)%>%
      arrange(desc(new.score))
    
    regret[i] <- group.utility$group.score[1] - group.utility1$group.score[1]
    print(regret)
  }
  
  mylist <- list(correlation, regret)
  
  return(mylist)
}

test.random <- random.group.search(5, 15)
test.random2 <- random.group.search(10, 15)
test.random3 <- random.group.search(10,15)
test.random4 <- random.group.search(10, 15)
test.random5 <- random.group.search(10, 15)
test.random6 <- random.group.search(10, 15)
test.random7 <- random.group.search(10, 15)
test.random8 <- random.group.search(15, 15)

random.correlation <- list.append(test.random[[1]], test.random2[[1]], test.random3[[1]], test.random4[[1]], test.random5[[1]], test.random6[[1]], test.random7[[1]], test.random8[[1]])

mean(random.correlation)
var(random.correlation)

random.regret <- list.append(test.random[[2]], test.random2[[2]], test.random3[[2]], test.random4[[2]], test.random5[[2]], test.random6[[2]], test.random7[[2]], test.random8[[2]])

mean(random.regret)
var(random.regret)

doptimal.group.search <- function(nruns, t){
  
  correlation <- c()
  regret <- c()
  
  for(i in 1:nruns){
    
    random.search <- group.recommendation.doptimalonly(t)
    
    random.ranking <- as.matrix(people.utility)%*%as.matrix(random.search[2][[1]][2:5])
    
    correlation[i] <- cor(random.ranking, group.utility$group.score)
    
    print(correlation)
    
    group.utility1 <- group.utility%>%
      mutate(new.score = random.search[2][[1]][2]*p1.utility + random.search[2][[1]][3]*p2.utility + random.search[2][[1]][4] * p3.utility 
             + random.search[2][[1]][5] * p4.utility)%>%
      arrange(desc(new.score))
    
    regret[i] <- group.utility$group.score[1] - group.utility1$group.score[1]
    print(regret)
  }
  
  mylist <- list(correlation, regret)
  
  return(mylist)
}

test.doptimal <- doptimal.group.search(5, 15)

test.doptimal2 <- doptimal.group.search(20, 15)

test.doptimal3 <- doptimal.group.search(55, 15)

doptimal.correlation <- list.append(test.doptimal[[1]], test.doptimal2[[1]], test.doptimal3[[1]])

mean(doptimal.correlation)
var(doptimal.correlation)

doptimal.regret <- list.append(test.doptimal[[2]], test.doptimal2[[2]], test.doptimal3[[2]])

mean(doptimal.regret)
var(doptimal.regret)
sd(doptimal.regret)

aggressive.group.search <- function(nruns, t){

  correlation <- c()
  regret <- c()
  
  for(i in 1:nruns){
    
    random.search <- group.recommendation(t)
    
    random.ranking <- as.matrix(people.utility)%*%as.matrix(random.search[2][[1]][[15]][2:5])
    
    correlation[i] <- cor(random.ranking, group.utility$group.score)
    
    print(correlation)
    
    group.utility1 <- group.utility%>%
      mutate(new.score = random.search[2][[1]][[15]][2]*p1.utility + random.search[2][[1]][[15]][3]*p2.utility + random.search[2][[1]][[15]][4] * p3.utility 
             + random.search[2][[1]][[15]][5] * p4.utility)%>%
      arrange(desc(new.score))
    
    regret[i] <- group.utility$group.score[1] - group.utility1$group.score[1]
    print(regret)
  }
  
  mylist <- list(correlation, regret)
  
  return(mylist)  
  
}

test.upperconfidence <- aggressive.group.search(5, 15)
test.upperconfidence2 <- aggressive.group.search(10, 15)
test.upperconfidence3 <- aggressive.group.search(10, 15)
ntest.upperconfidence4 <- aggressive.group.search(20, 15)
test.upperconfidence5 <- aggressive.group.search(25, 15)
test.upperconfidence6 <- aggressive.group.search(10, 15)

upperconfidence.correlation <- list.append(test.upperconfidence[[1]], test.upperconfidence2[[1]], test.upperconfidence3[[1]], test.upperconfidence4[[1]], test.upperconfidence5[[1]], test.upperconfidence6[[1]])

mean(upperconfidence.correlation)
var(upperconfidence.correlation)

upperconfidence.regret <- list.append(test.upperconfidence[[2]], test.upperconfidence2[[2]], test.upperconfidence3[[2]], test.upperconfidence4[[2]], test.upperconfidence5[[2]], test.upperconfidence6[[2]])

mean(upperconfidence.regret)
var(upperconfidence.regret)

hybrid.group.search <- function(nruns, t){
  
  correlation <- c()
  regret <- c()
  
  for(i in 1:nruns){
    
   random.search <- group.recommendation.hybrid(t)
    
    random.ranking <- as.matrix(people.utility)%*%as.matrix(random.search[[2]][2:5])
    
    correlation[i] <- cor(random.ranking, group.utility$group.score)
    
    print(correlation)
    
    group.utility1 <- group.utility%>%
      mutate(new.score = random.search[[2]][2]*p1.utility + random.search[[2]][3]*p2.utility + random.search[[2]][4] * p3.utility 
             + random.search[[2]][5] * p4.utility)%>%
      arrange(desc(new.score))
    
    regret[i] <- group.utility$group.score[1] - group.utility1$group.score[1]
    print(regret)
  }
  
  
  
  mylist <- list(correlation, regret)
  
  return(mylist)
  
}

test.hybrid <- hybrid.group.search(20, 15)

test.hybrid2 <- hybrid.group.search(65, 15)

hybrid.correlation <- list.append(test.hybrid[[1]], test.hybrid2[[1]])

mean(hybrid.correlation)
sd(hybrid.correlation)

hybrid.regret <- list.append(test.hybrid[[2]], test.hybrid2[[2]])

mean(hybrid.regret)
sd(hybrid.regret)

hybrid.group.search2 <- function(nruns, t){
  
  correlation <- c()
  regret <- c()
  
  data.new <- c()
  
  for(i in 1:nruns){
    
    random.search <- group.recommendation.hybrid2(t)
    
    random.ranking <- as.matrix(people.utility)%*%as.matrix(random.search[[2]][2:5])
    
    correlation[i] <- cor(random.ranking, group.utility$group.score)
    
    data.new[[i]] <- random.search[[1]]
    
    print(correlation)
    
    group.utility1 <- group.utility%>%
      mutate(new.score = random.search[[2]][2]*p1.utility + random.search[[2]][3]*p2.utility + random.search[[2]][4] * p3.utility 
             + random.search[[2]][5] * p4.utility)%>%
      arrange(desc(new.score))
    
    regret[i] <- group.utility$group.score[1] - group.utility1$group.score[1]
    print(regret)
  }
  
  
  
  mylist <- list(correlation, regret, data.new)
  
  return(mylist)
  
}

test.hybrid2.1 <- hybrid.group.search2(85, 15)

test.hybrid2.2 <- hybrid.group.search2(15, 15)

mean.correlation <- cbind(mean(random.correlation), mean(doptimal.correlation), mean(upperconfidence.correlation), mean(hybrid.correlation), mean(test.hybrid2.1[[1]]))
sd.correlation <- cbind(sd(random.correlation), sd(doptimal.correlation), sd(upperconfidence.correlation), sd(hybrid.correlation), sd(test.hybrid2.1[[1]]))

boxplot(random.correlation, doptimal.correlation, upperconfidence.correlation)

mean.regret <- cbind(mean(random.regret), mean(doptimal.regret), mean(upperconfidence.regret), mean(hybrid.regret), mean(test.hybrid2.1[[2]]))
sd.regret <- cbind(sd(random.regret), sd(doptimal.regret), sd(upperconfidence.regret), sd(hybrid.regret))

boxplot(random.correlation, doptimal.correlation, upperconfidence.correlation, hybrid.correlation, test.hybrid2.1[[1]],
        main = "Correlation of Recommendation Algorithm",
        names = c("Random", "Information Maximation", "UCB", "Hybrid (5)", "Hybrid (2)"),
        xlab = "Algorithms",
        ylab = "Correlation with group truth")


boxplot(random.regret, doptimal.regret, upperconfidence.regret, hybrid.regret, test.hybrid2.1[[2]],
        main = "Regret of Recommendation Algorithm",
        names = c("Random", "Information Maximation", "UCB", "Hybrid (5)", "Hybrid (2)"),
        xlab = "Algorithms",
        ylab = "Regret with group truth")

constGLM <- function(X, y, Xtest){
  # constraints
  # Ubar: 0.999 < theta1 < 1.001
  # SD: -1/sqrt(2) < theta2 < 1/sqrt(2)
  ui <- matrix(c(1, 0, -1, 0, 0, 1, 0, -1), nrow = 4, ncol = 2, byrow = TRUE)
  ci <- c(0.999, -1.001, -1/sqrt(2), -1/sqrt(2))

  # constrained log-likelihood
  CLL <- function(par, X, y){
    eta <- X %*% par
    p <- exp(eta)/(1 + exp(eta))
    ll <- sum(y*log(p) + (1-y)*log(1-p))
    return(-ll)
  }
  
  # Optimize
  optims <- constrOptim(c(1, 0), CLL, ui = ui, ci = ci, X = X, y = y, grad = NULL)
  pars <- optims$par
  print(pars)
  
  # Return predicted probabilities
  etatest <- Xtest %*% pars
  output.list = list(pars, exp(etatest)/(1+exp(etatest)), etatest)
  return(output.list)
}

group.search.minmax <- function(t, g){

  id.max <- c()
  pars.list <- c()
  prob <- c()
  corscglm <- c()
  for(i in 1:g){
    
    
    new.data <- group.utility
    optimal.design.matrix <- as.matrix(group.utility[8:12])
    
    doptimaldesign <- Dopt.design(t, data = optimal.design.matrix, formula = ~p1.utility + p2.utility + p3.utility + p4.utility)
    
    x <- doptimaldesign$p1.utility
    z <- doptimaldesign$p2.utility
    q <- doptimaldesign$p3.utility
    r <- doptimaldesign$p4.utility
    
    eta_fun <- function(a, b, c, d) apply(cbind(a, b, c, d), 1, max)
    # eta <- eta_fun(x, z, q, r)
    # p <- exp(eta)/(1 + exp(eta))
    # y <- rbinom(t, 1, p)
    
    p.x <- exp(x)/(1+exp(x))
    p.z <- exp(z)/(1+exp(z))
    p.q <- exp(q)/(1+exp(q))
    p.r <- exp(r)/(1+exp(r))
    
    y.x <- rbinom(t, 1, p.x)
    y.z <- rbinom(t, 1, p.z)
    y.q <- rbinom(t, 1, p.q)
    y.r <- rbinom(t, 1, p.r)
    
    y <- eta_fun(y.x, y.z, y.q, y.r)
    
    #y <- append(y.x, y.z)%>%
      #append(y.q)%>%
      #append(y.r)
    
    x.test <- new.data$p1.utility
    z.test <- new.data$p2.utility
    q.test <- new.data$p3.utility
    r.test <- new.data$p4.utility
    
    p.xtest <- exp(x.test)/(1+exp(x.test))
    p.ztest <- exp(z.test)/(1+exp(z.test))
    p.qtest <- exp(q.test)/(1+exp(q.test))
    p.rtest <- exp(r.test)/(1+exp(r.test))
    
    y.xtest <- rbinom(162, 1, p.xtest)
    y.ztest <- rbinom(162, 1, p.ztest)
    y.qtest <- rbinom(162, 1, p.qtest)
    y.rtest <- rbinom(162, 1, p.rtest)
    
    #ytest <- append(as.factor(y.x), as.factor(y.z))%>%
      #append(as.factor(y.q))%>%
      #append(as.factor(y.r))
    
    ytest <- eta_fun(y.xtest, y.ztest, y.qtest, y.rtest)
    
    # etatest <- eta_fun(x.test, z.test, q.test, r.test)
    # ptest <- exp(etatest)/(1 + exp(etatest))
    Xtest <- data.frame(x = x.test, z = z.test, q = q.test, r = r.test)
    # ytest <- factor(rbinom(162, 1, ptest))
    # 
    ubar_fun <- function(a, b, c, d) apply(cbind(a, b, c, d), 1, mean)    
    S_fun <- function(a, b, c, d) apply(cbind(a, b, c, d), 1, sd)    
    ubar <- ubar_fun(x, z, q, r)  
    S <- S_fun(x, z, q, r)
    ubartest <- ubar_fun(x.test, z.test, q.test, r.test)
    Stest <- S_fun(x.test, z.test, q.test, r.test)
    
    UBAR_repeat <- rep(ubar, each = 4)
    S_repeat <- rep(S, each = 4)
    
    UBAR_TEST_Repeat <- rep(ubartest, each = 4)
    STest_Repeat <- rep(Stest, each = 4)
    
    cGLM1 <- constGLM(X = cbind(ubar, S), y = y, Xtest = cbind(ubartest, Stest))
    
    id.max[i] <- which.max(cGLM1[[2]])
    pars.list[[i]] <- cGLM1[[1]]
    prob[[i]] <- cGLM1[[2]]
    
  }  
  
  output <- list(id.max, pars.list, prob)

  return(output)
}

test.minimax <- group.search.minmax(15, 1000)
test.max <- group.search.minmax(15, 1000)


group.search.minmax1 <- function(t, g){
  
  id.max <- c()
  pars.list <- c()
  for(i in 1:g){
    
    
    new.data <- group.utility
    optimal.design.matrix <- as.matrix(group.utility[8:12])
    
    doptimaldesign <- Dopt.design(t, data = optimal.design.matrix, formula = ~p1.utility + p2.utility + p3.utility + p4.utility)
    
    x <- doptimaldesign$p1.utility
    z <- doptimaldesign$p2.utility
    q <- doptimaldesign$p3.utility
    r <- doptimaldesign$p4.utility
    
    eta_fun <- function(a, b, c, d) apply(cbind(a, b, c, d), 1, max)
    eta <- eta_fun(x, z, q, r)
    p <- exp(eta)/(1 + exp(eta))
    y <- rbinom(t, 1, p)
    
    x.test <- new.data$p1.utility
    z.test <- new.data$p2.utility
    q.test <- new.data$p3.utility
    r.test <- new.data$p4.utility
    
    etatest <- eta_fun(x.test, z.test, q.test, r.test)
    ptest <- exp(etatest)/(1 + exp(etatest))
    Xtest <- data.frame(x = x.test, z = z.test, q = q.test, r = r.test)
    ytest <- factor(rbinom(162, 1, ptest))
     
    ubar_fun <- function(a, b, c, d) apply(cbind(a, b, c, d), 1, mean)    
    S_fun <- function(a, b, c, d) apply(cbind(a, b, c, d), 1, sd)    
    ubar <- ubar_fun(x, z, q, r)  
    S <- S_fun(x, z, q, r)
    ubartest <- ubar_fun(x.test, z.test, q.test, r.test)
    Stest <- S_fun(x.test, z.test, q.test, r.test)
    
    cGLM1 <- constGLM(X = cbind(ubar, S), y = y, Xtest = cbind(ubartest, Stest))
    
    id.max[i] <- which.max(cGLM1[[2]])
    pars.list[[i]] <- cGLM1[[1]]
    
  }  
  
  output <- list(id.max, pars.list)
  return(output)
}

test.minimax2 <- group.search.minmax1(15,1000)

min(group.utility$p1.utility)
min(group.utility$p2.utility)
min(group.utility$p3.utility)
min(group.utility$p4.utility)
which.min(group.utility$p3.utility)

for (i in 1:162){
  
  current.value[i] <- min(group.utility[i,9:12])
  
  
}

for (i in 1:162){
  
  current.value[i] <- max(group.utility[i, 9:12])
}

p1.utility <- p1.utility%>%
  mutate(sd = sd(utility))%>%
  dplyr::select(utility, sd)

X1 <- as.matrix(p1.utility)

p2.utility <- p2.utility%>%
  mutate(sd = sd(utility))%>%
  dplyr::select(utility, sd)

X2 <- as.matrix(p2.utility)

p3.utility <- p3.utility%>%
  mutate(sd = sd(utility))%>%
  dplyr::select(utility, sd)

X3 <- as.matrix(p3.utility)

p4.utility <- p4.utility%>%
  mutate(sd = sd(utility))%>%
  dplyr::select(utility, sd)

X4 <- as.matrix(p4.utility)

test.matrix <- group.utility[,1:7]

test.comparisons <- combn(test.matrix, 2)

test.comparisons <- expand.grid()

partial.beta <- 0.01

ppi_1 <- rep(runif(n = 36, min = 30, max = 200))

ppi_2 <- rep(runif(n = 36, min = 30, max = 200))

ppi_1_2 <- ppi_1-ppi_2

